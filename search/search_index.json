{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Summary","text":"<p>This site contains the documentation for Klearwave.</p>"},{"location":"developer/","title":"Summary","text":"<p>We want to maintain a list of standards that pertain to all projects.  This is  an attempt to centralize common developer standards.  Any deviations from  common standards belong in the repo and or codebase that deviates from said  standards.</p>"},{"location":"developer/database/","title":"Database Standards","text":"<p>This page contains the agreed upon developer standards as it pertains to databases.</p>"},{"location":"developer/database/#design-standards","title":"Design Standards","text":""},{"location":"developer/database/#migrations-goose","title":"Migrations: Goose","text":"<p>Goose should be used in conjunction  with SQL files in order to achieve database migrations.  Migrations should exist at the top level of a repository in a <code>migrations/</code> folder.</p> <p>Example <code>migrations/</code> directory:</p> <pre><code>tree service-info/migrations/\nservice-info/migrations/\n\u251c\u2500\u2500 000001_create_versions_table.sql\n\u2514\u2500\u2500 000002_create_container_images_table.sql\n</code></pre> <p>Example <code>migration.sql</code> file:</p> <pre><code>-- +goose Up\nCREATE TABLE versions (\n    id SERIAL PRIMARY KEY,\n    version_id VARCHAR(32) NOT NULL UNIQUE,\n    stable BOOLEAN DEFAULT FALSE,\n    x_version INT,\n    y_version INT,\n    z_version INT,\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n);\n\n-- +goose Down\nDROP TABLE versions;\n</code></pre>"},{"location":"developer/database/#code-gorm","title":"Code: GORM","text":"<p>GORM should be used in conjunction with Go structs in order to tie database models to their underlying records:</p> <p>Example struct with GORM:</p> <pre><code>// ContainerImageBase is the base set of fields for all ContainerImage objects.\ntype ContainerImageBase struct {\n    Image      string `json:\"image,omitempty\" example:\"ghcr.io/klearwave/service-info:latest\" doc:\"Full container image including the registry, repository and tag.\"`\n    SHA256Sum  string `json:\"sha256sum,omitempty\" example:\"2d4b92db6941294f731cfe7aeca336eb8dba279171c0e6ceda32b9f018f8429d\" doc:\"SHA256 sum of the container image.\"`\n    CommitHash string `json:\"commit_hash,omitempty\" example:\"631af50a8bbc4b5e69dab77d51a3a1733550fe8d\" doc:\"Commit hash related to the image.\"`\n}\n</code></pre>"},{"location":"developer/database/#code-validation-and-mutation","title":"Code: Validation and Mutation","text":"<p>Use Golang as opposed to writing complex functions  in SQL, we should use proper code to validate inputs before inserting into the  database.  Additionally, we should also use proper code to mutate any incoming  database records.</p> <p>Example (Do not do this):</p> <p>Here is a sample SQL file with complex trigger functions (logic in SQL):</p> <pre><code>-- Function to validate semantic versioning format\n-- +goose StatementBegin\nCREATE OR REPLACE FUNCTION trigger_validate_version_id()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF NOT NEW.version_id ~ '^v\\d+\\.\\d+\\.\\d+$' THEN\n        RAISE EXCEPTION 'Invalid version_id format. Must be in the form vX.Y.Z';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n-- +goose StatementEnd\n</code></pre> <p>Example (Do this instead):</p> <p>Here is the same logic, written in code:</p> <pre><code>// ValidateVersionID checks if the given version ID follows the pattern vX.Y.Z\nfunc ValidateVersionID(versionID string) error {\n    validVersionPattern := `^v\\d+\\.\\d+\\.\\d+$`\n    re := regexp.MustCompile(validVersionPattern)\n    if !re.MatchString(versionID) {\n        return errors.New(\"Invalid version_id format. Must be in the form vX.Y.Z\")\n    }\n    return nil\n}\n</code></pre> <p>The above shows an example of a trigger function in SQL for validation.  While this does  enforce the data inserted closest to where it lives, it creates unneeded complexity and  additional technical debt (need to understand writing of SQL functions and the codebase  that calls it) that we want to avoid.  Additionally, services that run proper code are much easier to scale horizontally, so it is better to use resources outside of the database  in proper code than to stuff it all in the database.</p> <p>However, there is are exceptions to the rule...</p>"},{"location":"developer/database/#code-validation-exceptions","title":"Code: Validation Exceptions","text":"<ol> <li> <p>Length Validation: In the instance of length validation, it is better to enforce length validation at the  database level to avoid the need to validate in code and to enforce the data integrity  of what is stored in the database.  This is specific to string data which can be of  variable length.  We should look to implement string length validation in one of two manners:</p> </li> <li> <p>Variable Length: for variable length strings (strings which do not have a predetermined length), we  should use the <code>VARCHAR(n)</code> column type:</p> </li> </ol> <pre><code>    version_id VARCHAR(32) NOT NULL UNIQUE,\n</code></pre> <p>In the above example, a <code>version_id</code> can be different lengths (e.g. <code>v0.1.0</code> versue <code>v0.1.10</code>), so we  should use the <code>VARCHAR(n)</code> type.  This allows the database to not preallocate space and validates  that the data only allows a specific length (32).</p> <ul> <li>Non-Variable Length: for string data that has a pre-determined length, we should use the  <code>CHAR(n)</code> column type:</li> </ul> <pre><code>    sha256_sum CHAR(64) NOT NULL,\n    commit_hash CHAR(40) NOT NULL,\n</code></pre> <p>In the above example, a <code>sha256_sum</code> and <code>commit_hash</code> have pre-determined lengths and will always  only be those lengths, so we use the <code>CHAR(n)</code> to preallocate the space.</p>"},{"location":"platform/getting-started/","title":"Summary","text":"<p>The following is a guide for getting started with the Klearwave application platform.</p>"},{"location":"platform/getting-started/#initialize-the-cloud-account","title":"Initialize the Cloud Account","text":"<p>The first step in getting started with Klearwave is to initialize your cloud account.  Klearwave creates specific permissions in the account and utilizes those permissions to perform  followon operations.  These operations include such things as provisioning platforms.</p> <p>The following describes the flow for account initialization:</p> <p></p> <ol> <li> <p>For the initial step, we expect you to configure authentication to your specific cloud.  We will  use your initial credentials to create additional permissions that we use in followon operations.</p> <ul> <li>AWS</li> </ul> </li> <li> <p>Klearwave is designed to respect an individual organization's desire to use modern  infrastructure-as-code practices.  Thus, the first step to account initialization is to generate  a configuration that includes all inputs required for account initialization.  This configuration  may be forked, modified and re-used as each new cloud account needs to be initialized.</p> <pre><code>klearwave init platform account config --type=aws --output=/tmp/aws.yaml\n</code></pre> </li> <li> <p>The above command will output a file that contains all inputs for account initialization and  looks like the below:</p> <pre><code>apiVersion: infrastructure.klearwave.io/v0\nkind: AWSAccount\nmetadata:\n  name: aws\nspec:\n  supportLevel: community\n  allowedRoles: []\n</code></pre> </li> <li> <p>Once a configuration has been created and modified to the user liking, the configuration can then be used to initialize the AWS account.  It is important to note that the local user authentication  for the specific cloud account is used and should be configured prior to running the next command.</p> <pre><code>klearwave init platform account --config=/tmp/aws.yaml\n</code></pre> </li> </ol>"},{"location":"platform/glossary/","title":"Summary","text":"<p>There is certain terminology to be familiar with when operating the Klearwave application platform.  This  serves as a centralized point for common terminology that you will come across:</p> <ul> <li> <p>Capability - the foundation of any application platform.  This represents a capability that the  application platform delivers for applications that run on that platform to consume.  In Klearwave, a  capability is made up of a collection of components that are all tightly integrated with one another.</p> </li> <li> <p>Component - several components make up an individual application platform capability.  In the case  of Klearwave, a component is equivalent to an upstream project.  Typically, several different components  will make up a single capability.</p> </li> </ul>"},{"location":"submodules/service-info/docs/","title":"Informational Service","text":"<p>This service is meant to provide information about the service as a whole.  Users who  will ultimately consume the service will need to view information about the service to  make determinations about how to use the service in their environment.  The types  of information that should be exposed by the service are:</p> <ul> <li>Version information</li> <li>Policy information</li> </ul>"},{"location":"submodules/service-info/docs/#administrative-access","title":"Administrative Access","text":"<p>Publishing specific information to the informational service should be done with  administrative access only.  The ability to modify (e.g. <code>POST</code>, <code>PUT</code>, <code>DELETE</code>) parts  of the service should be heavily controlled and not available for general user  consumption.</p> <p>Below is a high-level idea of how this service may be controlled.  The design is highly  genericized to be portable to different technologies (e.g. on-prem versus public cloud)</p> <p></p>"}]}