{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Summary","text":"<p>This site contains the documentation for Klearwave.</p>"},{"location":"developer/","title":"Summary","text":"<p>We want to maintain a list of standards that pertain to all projects.  This is  an attempt to centralize common developer standards.  Any deviations from  common standards belong in the repo and or codebase that deviates from said  standards.</p>"},{"location":"developer/database/","title":"Database Standards","text":"<p>This page contains the agreed upon developer standards as it pertains to databases.</p>"},{"location":"developer/database/#design-standards","title":"Design Standards","text":"<ol> <li>GORM for database models: GORM should be used in conjunction with Go structs in order to tie database models to their underlying records:</li> </ol> <p>Example struct with GORM:</p> <pre><code>// ContainerImageBase is the base set of fields for all ContainerImage objects.\ntype ContainerImageBase struct {\n    Image      string `json:\"image,omitempty\" example:\"ghcr.io/klearwave/service-info:latest\" doc:\"Full container image including the registry, repository and tag.\"`\n    SHA256Sum  string `json:\"sha256sum,omitempty\" example:\"2d4b92db6941294f731cfe7aeca336eb8dba279171c0e6ceda32b9f018f8429d\" doc:\"SHA256 sum of the container image.\"`\n    CommitHash string `json:\"commit_hash,omitempty\" example:\"631af50a8bbc4b5e69dab77d51a3a1733550fe8d\" doc:\"Commit hash related to the image.\"`\n}\n</code></pre> <ol> <li>Goose for database migrations: Goose should be used in conjunction  with SQL files in order to achieve database migrations.  Migrations should exist at the top level of a repository in a <code>migrations/</code> folder.</li> </ol> <p>Example <code>migrations/</code> directory:</p> <pre><code>tree service-info/migrations/\nservice-info/migrations/\n\u251c\u2500\u2500 000001_create_versions_table.sql\n\u2514\u2500\u2500 000002_create_container_images_table.sql\n</code></pre> <p>Example <code>migration.sql</code> file:</p> <pre><code>-- +goose Up\nCREATE TABLE versions (\n    id SERIAL PRIMARY KEY,\n    version_id VARCHAR(32) NOT NULL UNIQUE,\n    latest BOOLEAN DEFAULT FALSE,\n    x_version INT,\n    y_version INT,\n    z_version INT,\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\n-- +goose Down\nDROP TABLE versions;\n</code></pre> <ol> <li>Code for validation and mutation: as opposed to writing complex functions  in SQL, we should use proper code to validate inputs before inserting into the  database.  Additionally, we should also use proper code to mutate any incoming  database records.</li> </ol> <p>Example (Do not do this):</p> <pre><code>-- Function to validate semantic versioning format\n-- +goose StatementBegin\nCREATE OR REPLACE FUNCTION trigger_validate_version_id()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF NOT NEW.version_id ~ '^v\\d+\\.\\d+\\.\\d+$' THEN\n        RAISE EXCEPTION 'Invalid version_id format. Must be in the form vX.Y.Z';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n-- +goose StatementEnd\n</code></pre> <p>Example (Do this instead):</p> <pre><code>// ValidateVersionID checks if the given version ID follows the pattern vX.Y.Z\nfunc ValidateVersionID(versionID string) error {\n    validVersionPattern := `^v\\d+\\.\\d+\\.\\d+$`\n    re := regexp.MustCompile(validVersionPattern)\n    if !re.MatchString(versionID) {\n        return errors.New(\"Invalid version_id format. Must be in the form vX.Y.Z\")\n    }\n    return nil\n}\n</code></pre> <p>The above shows an example of a trigger function in SQL for validation.  While this does  enforce the data inserted closest to where it lives, it creates unneeded complexity and  additional technical debt (need to understand writing of SQL functions and the codebase  that calls it) that we want to avoid.</p>"},{"location":"platform/getting-started/","title":"Summary","text":"<p>The following is a guide for getting started with the Klearwave application platform.</p>"},{"location":"platform/getting-started/#initialize-the-cloud-account","title":"Initialize the Cloud Account","text":"<p>The first step in getting started with Klearwave is to initialize your cloud account.  Klearwave creates specific permissions in the account and utilizes those permissions to perform  followon operations.  These operations include such things as provisioning platforms.</p> <p>The following describes the flow for account initialization:</p> <p></p> <ol> <li> <p>For the initial step, we expect you to configure authentication to your specific cloud.  We will  use your initial credentials to create additional permissions that we use in followon operations.</p> <ul> <li>AWS</li> </ul> </li> <li> <p>Klearwave is designed to respect an individual organization's desire to use modern  infrastructure-as-code practices.  Thus, the first step to account initialization is to generate  a configuration that includes all inputs required for account initialization.  This configuration  may be forked, modified and re-used as each new cloud account needs to be initialized.</p> <pre><code>klearwave init platform account config --type=aws --output=/tmp/aws.yaml\n</code></pre> </li> <li> <p>The above command will output a file that contains all inputs for account initialization and  looks like the below:</p> <pre><code>apiVersion: infrastructure.klearwave.io/v0\nkind: AWSAccount\nmetadata:\n  name: aws\nspec:\n  supportLevel: community\n  allowedRoles: []\n</code></pre> </li> <li> <p>Once a configuration has been created and modified to the user liking, the configuration can then be used to initialize the AWS account.  It is important to note that the local user authentication  for the specific cloud account is used and should be configured prior to running the next command.</p> <pre><code>klearwave init platform account --config=/tmp/aws.yaml\n</code></pre> </li> </ol>"},{"location":"submodules/service-info/docs/","title":"Informational Service","text":"<p>This service is meant to provide information about the service as a whole.  Users who  will ultimately consume the service will need to view information about the service to  make determinations about how to use the service in their environment.  The types  of information that should be exposed by the service are:</p> <ul> <li>Version information</li> <li>Policy information</li> </ul>"},{"location":"submodules/service-info/docs/#administrative-access","title":"Administrative Access","text":"<p>Publishing specific information to the informational service should be done with  administrative access only.  The ability to modify (e.g. <code>POST</code>, <code>PUT</code>, <code>DELETE</code>) parts  of the service should be heavily controlled and not available for general user  consumption.</p> <p>Below is a high-level idea of how this service may be controlled.  The design is highly  genericized to be portable to different technologies (e.g. on-prem versus public cloud)</p> <p></p>"}]}